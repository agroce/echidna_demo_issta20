\section{Experimental Evaluation}

In order to evaluate Echidna, we compared its performance to the MythX platform \cite{mythx}, accessed via the {\tt solfuzz} \cite{solfuzz} interface, on a set of reachability targets, produced by insertion of {\tt assert(false)} statements, on a set of benchmark contracts \cite{vsbenchmark} produced for the VeriSmart safety-checker \cite{VeriSmart}.  We compared to MythX as it was the only other currently-working fuzzer we are aware of that easily supports arbitrary reachability targets (via supporting assertion-checking).  Comparing with a fuzzer that only supports a custom set of built-in detectors, such as ContractFuzzer \cite{contractfuzzer}, which does not support arbitrary assertions in Solidity code, is difficult to do in a fair way, as any differences are likely to be due to specification semantics, not exploration capability.  ChainFuzz \cite{chainfuzz}, which in theory offers this capability, unfortunately fails to run on our examples, or its own provided sample contract, terminating with the message: {\tt panic: error unmarshalling transaction: json: cannot unmarshal string into Go struct field transaction.gas of type uint64}, when run inside the docker image it creates.  The last commit was in April of 2019, and it is not clear if the tool is maintained, since the same problem that we encountered was submitted as a github issue in April of 2019:  \url{https://github.com/ChainSecurity/ChainFuzz/issues/2}.

MythX is a commercial platform for analyzing smart contracts.  It offers a free tier of access, and, via the {\tt solfuzz} tool, this makes it possible to easily run assertion checking on contracts, with ease-of-use similar to Echidna.  The primary differences to a user are that {\tt solfuzz}/MythX does not work offline, and there is limit of 40 runs/month and 5 minutes of compute time for the free tier.  The {\tt solfuzz} tool runs a short-duration analysis, that in our experiments took about two minutes, with an upper bound of 5 minutes, that is available for non-paying users (it can also run 20 minute or 45 minute analyses for users with paid MythX accounts).  MythX analyzes the submitted contracts using the Mythril symbolic execution tool \cite{mythril-code} and the Harvey fuzzer \cite{harvey}.  Harvey is a state-of-the-art closed-source tool, with a research paper describing its design and implementation in ICSE 2020 \cite{harvey}.

To compare MythX and Echidna, we first analyzed the contracts in the VeriSmart benchmark \cite{vsbenchmark} and identified all contracts such that 1) both tools ran on the contract\footnote{MythX/{\tt solfuzz} failed to compile some contracts for unknown reasons, and timed out without producing results on others, and Echidna does not currently easily support contracts with constructors that require arguments.} and 2) neither tool reported any issues with the contract.  This left us with 12 clean contracts, over which to compare the tools' ability to explore behavior.  We inserted {\tt assert(false)} statements into each of these contracts, after every statement, resulting in 459 contracts representing reachability targets.  We discarded 44 of these, as the assert was unconditionally executed in the contract's constructor, so no behavior exploration was required to reach it.

We then ran {\tt solfuzz}'s quick check and Echidna with a two-minute timeout on a randomly selected set of 40 targets.  Echidna was able to produce a transaction sequence reaching the assert for 19 of the 40 targets, and {\tt solfuzz}/MythX generated a reaching sequence for 15 of the 40, all of which were also reached by Echidna.  While the time to reach the assertion was usually close to two minutes with {\tt solfuzz}, Echidna needed a maximum of only 52 seconds to hit the hardest target; the mean time required was 13.9 seconds, and the median time was only 6.9 seconds.

We manually examined the targets not deteced by either tool, and believe them all to represent unreachable targets, usually due to being inserted after an unavoidable {\tt return} statement, or being inserted in the {\tt SafeMath} contract, which redefines {\tt assert}.  Of the reachable targets, Echidna was able to produce sequences for 100\%, and {\tt solfuzz}/MythX for 78.9\%.  For Echidna, we repeated each experiment 10 more times, and Echidna always reached each target.  Due to the limit on MythX runs, even under a developer license (200 executions/month), we were unable to statistically determine the stability of its results to the same degree, but can confirm that  for two of the targets, a second run succeeded, and for two of the targets three additional runs still failed to reach the assert.  Running {\tt solfuzz} with the {\tt --mode standard} argument (not available to free accounts) did detect all four, but it required at least 15 minutes of analysis time in each case.

\begin{figure}
  \begin{code}
if (balances[\_from] >= \_amount
  \&\& allowed[\_from][msg.sender] >= \_amount
  \&\& \_amount > 0
  \&\& balances[\_to] + \_amount > balances[\_to])\{
    balances[\_from] -= \_amount;
    allowed[\_from][msg.sender] -= \_amount;
\vspace{0.1in}
    assert(false);
  \end{code}
  \caption{Code for a difficult reachablility target.}
  \label{fig:code}
  \end{figure}

  Figure \ref{fig:code} shows the key part of the code for one of the four targets Echidna, but not {\tt solfuzz}/MythX (even with additional runs), was able to reach within 2 minutes.  The assert can only be executed when a call has been made to the {\tt approve} function, allowing the sender of the {\tt transferFrom} call to send an amount greater than or equal to {\tt \_amount}, and when  the contract from which transfer is to be made has a token balance greater than {\tt \_amount}.  Generating a sequence with the proper set of functions called and the proper relationships between variables is a difficult problem, but Echidna's heuristic use of small numeric values in arguments and heuristic repetiton of addresses in arguments and as message senders is able to navigate the set of constraints easily.  A similar set of constraints over allowances and/or senders and function arguments is involved in two of the other four targets where Echidna performs better.

For a larger, more realistic example, we modified the actual blockchain code for the TetherToken contract (\url{https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code}), and again inserted {\tt assert(false)} targets to investigate reachability of the code.  Tether is arguably the most famous ``stablecoin'', a cryptocurrency pegged to a real-world currency, in this case the US dollar, and has a market cap of approximately 6 billion dollars.  The contract has been involved in more than 23 million blockchain transactions.
We again randomly selected 40 targets, and ran two minutes of testing on each with {\tt solfuzz} and Echidna.  Echidna was able to reach 26 of the 40 targets, with mean and median runtimes of 32 and 27 seconds.  The longest run required 83 seconds.  On the other hand, {\tt solfuzz}/MythX was only able to reach one of the targets using the quick two-minute search (and the search only took 44 seconds).   The target was one that Echidna failed to detect.