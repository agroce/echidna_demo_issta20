\section{Introduction}

Smart contracts for the Ethereum blockchain \cite{buterin2013whitepaper}, usually written in the Solidity language \cite{wood2014yellow}, facilitate and verify high-value financial transactions, as well as tracking physical goods and intellectual property.  It is essential that such largely autonomous programs be correct and secure.  Unfortunately, such contracts are often \emph{not} correct and secure \cite{SurveyAttacks}.  Recent work surveying and categorizing flaws in critical contracts \cite{FC20} established that fuzzing, using custom user-defined properties, might detect up to 63\% of the most severe and exploitable flaws in contracts.  It is therefore critical to make high-quality, easy-to-use fuzzing available to smart contract developers and security auditors.

Echidna \cite{echidna-code} is an open source Ethereum smart contract fuzzer that supports user-defined properties (for property-based testing \cite{ClaessenH00}, as well as assertion checking and gas use estimation.  Echidna supports the Solidity and Vyper smart contract languages and most contract development frameworks, including truffle and embark. Trail of Bits has used Echidna internally in numerous code audits \cite{FC20,reports}.
The use of Echidna in internal audits is a key driver in three primary design goals for Echidna. Echidna must be:

\begin{enumerate}
\item {\bf Effective:}  If Echidna is unable to explore contract behavior in order to find faults, e.g., producing poor coverage of contract/blockchain state, then it is not a useful tool to apply in code audits.  Both security auditors and other users' most important goal is to be able to find bugs.
\item {\bf Usable:} If Echidna is difficult to apply to smart contracts, auditors and other users will not find it effective, even if technically the tool performs well once it can be applied.  Difficult-to-automate workflows, reliance on external tools (e.g., forcing users to set up a private blockchain and deploy contracts to it), unsupported language features, and complex configuration options without meaningful defaults: all of these limit the practical, if not theoretical, effectiveness of a tool.  Echidna's design is focused on ease-of-use for practical bug-finding.
\item {\bf Fast:}  Finally, it is worth noting as a separate category, though relevant to both effectiveness and usabliity, that Echidna is designed to provide \emph{fast} feedback in most cases.  While some subtle flaws inherently require a long analysis time, Echidna is tuned to detect violations quickly when this is possible.  
\end{enumerate}

The third design goal is, in our experience, essential for supporting the first two design goals.  Quick turnaround makes it practical to apply a tool during development, and makes tuning user-defined properties easy; if every run requires even 10 minutes to produce useful results, incremental improvement of properties is painful and inefficient.  This is why most property-based testing tools have a very small default runtime or number of tests.  Speed also makes use of a tool in CI (\url{https://crytic.io}) more practical. Finally, effectiveness can be more easily improved if turnaround is usually quick: a fast fuzzer can be tuned using mutation testing \cite{MutationSurvey} or experimental runs using a large set of configurations on a large set of benchmark contracts.  The size of the statistical basis for decision-making and parameter choices explored is directly limited by the runtime of the tool.  Of course, Echidna supports long runtimes:  there is no upper bound on how long Echidna can execute, and with coverage-based feedback there is a long-term improvement in test generation quality.  Nonetheless, Echidna aims to find most problems it can detect in a matter of minutes, preferably fewer than five minutes.

Fuzzing smart contracts introduces some challenges that are unusual for fuzzer development.  First, a large amount of engineering effort is required to faithfully represent the semantics of blockchain execution; this is a different challenge than executing instrumented native binaries.  Second, the core problem, rather than generation of arbitrary byte buffers, is one of transaction sequence generation, which is more akin to the problem of unit test generation \cite{Pacheco} than traditional fuzzing.  This makes it critically important to choose parameters such as the length of sequences \cite{ASE08} that are not normally as important in fuzzing or in single-value-generation as in Haskell's QuickCheck.  Finally, in the smart contract context, finding inputs that cause pathological execution times is not an exotic, unusual concern, as in traditional fuzzing \cite{lemieux2018perffuzz}.  Execution on the blockchain requires use of \emph{gas}, which has a price in cryptocurrency; inefficiency can be costly, and malicious inputs can lock a contract by making all transactions require more gas than a transaction is allowed to use.  Therefore producing \emph{quantitative} output of maximum gas usage is an important fuzzer feature, alongside more traditional correctness checks.  Echidna incorporates a worst-case gas estimator into a general-purpose fuzzer, rather than forcing users to add a special-purpose gas-estimation tool \cite{albert2019gasol,ma2019gasfuzz} to their workflow.