\section{Introduction}

Smart contracts for the Ethereum blockchain \cite{buterin2013whitepaper}, usually written in the Solidity language \cite{wood2014yellow}, facilitate and verify high-value financial transactions, as well as tracking physical goods and intellectual property.  It is essential that such largely autonomous programs be correct and secure.  Unfortunately, such contracts are often \emph{not} correct and secure \cite{SurveyAttacks}.  Recent work surveying and categorizing flaws in critical contracts \cite{FC20} established that fuzzing, using custom user-defined properties, might detect up to 63\% of the most severe and exploitable flaws in contracts.  It is therefore critical to make high-quality, easy-to-use fuzzing available to smart contract developers and security auditors.

Echidna \cite{echidna-code} is an open source Ethereum smart contract fuzzer that supports user-defined properties (for property-based testing \cite{ClaessenH00}, as well as assertion checking and gas use estimation.  Echidna supports the Solidity and Vyper smart contract languages and most contract development frameworks, including truffle and embark. Trail of Bits has used Echidna internally in numerous code audits \cite{FC20,reports}.
The use of Echidna in internal audits is a key driver in three primary design goals for Echidna. Echidna must be:

\begin{enumerate}
\item {\bf Effective:}  If Echidna is unable to explore contract behavior in order to find faults, e.g., producing poor coverage of contract/blockchain state, then it is not a useful tool to apply in code audits.  Both security auditors and other users' most important goal is to be able to find bugs.
\item {\bf Usable:} If Echidna is difficult to apply to smart contracts, auditors and other users will not find it effective, even if technically the tool performs well once it can be applied.  Difficult-to-automate workflows, reliance on external tools (e.g., forcing users to set up a private blockchain and deploy contracts to it), unsupported language features, and complex configuration options without meaningful defaults: all of these limit the practical, if not theoretical, effectiveness of a tool.  Echidna's design is focused on ease-of-use for practical bug-finding.
\item {\bf Fast:}  Finally, it is worth noting as a separate category, though relevant to both effectiveness and usabliity, that Echidna is designed to provide \emph{fast} feedback in most cases.  While some subtle flaws inherently require a long analysis time, Echidna is tuned to detect violations quickly when this is possible.  
\end{enumerate}

The third design goal is, in our experience, essential for supporting the first two design goals.  Quick turnaround makes it practical to apply a tool during development, and makes tuning user-defined properties easy; if every run requires even 10 minutes to produce useful results, incremental improvement of properties is painful and inefficient.  This is why most property-based testing tools have a very small default runtime or number of tests.  Speed also makes use of a tool in CI (\url{https://crytic.io}) more practical. Finally, effectiveness can be more easily improved if turnaround is usually quick: a fast fuzzer can be tuned using mutation testing \cite{MutationSurvey} or experimental runs using a large set of configurations on a large set of benchmark contracts.  The size of the statistical basis for decision-making and parameter choices explored is directly limited by the runtime of the tool.  Of course, Echidna supports long runtimes:  there is no upper bound on how long Echidna can execute, and with coverage-based feedback there is a long-term improvement in test generation quality.  Nonetheless, Echidna aims to find most problems it can detect in a matter of minutes, preferably fewer than five minutes.